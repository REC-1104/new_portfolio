{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\nvar BIN_COUNT = 32;\nvar binsSort = function binsSort(a, b) {\n  return a.candidate - b.candidate;\n};\nvar sahBins = new Array(BIN_COUNT).fill().map(function () {\n  return {\n    count: 0,\n    bounds: new Float32Array(6),\n    rightCacheBounds: new Float32Array(6),\n    leftCacheBounds: new Float32Array(6),\n    candidate: 0\n  };\n});\nvar leftBounds = new Float32Array(6);\nexport function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n  var axis = -1;\n  var pos = 0;\n\n  // Center\n  if (strategy === CENTER) {\n    axis = getLongestEdgeIndex(centroidBoundingData);\n    if (axis !== -1) {\n      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    }\n  } else if (strategy === AVERAGE) {\n    axis = getLongestEdgeIndex(nodeBoundingData);\n    if (axis !== -1) {\n      pos = getAverage(triangleBounds, offset, count, axis);\n    }\n  } else if (strategy === SAH) {\n    var rootSurfaceArea = computeSurfaceArea(nodeBoundingData);\n    var bestCost = TRIANGLE_INTERSECT_COST * count;\n\n    // iterate over all axes\n    var cStart = offset * 6;\n    var cEnd = (offset + count) * 6;\n    for (var a = 0; a < 3; a++) {\n      var axisLeft = centroidBoundingData[a];\n      var axisRight = centroidBoundingData[a + 3];\n      var axisLength = axisRight - axisLeft;\n      var binWidth = axisLength / BIN_COUNT;\n\n      // If we have fewer triangles than we're planning to split then just check all\n      // the triangle positions because it will be faster.\n      if (count < BIN_COUNT / 4) {\n        // initialize the bin candidates\n        var truncatedBins = _toConsumableArray(sahBins);\n        truncatedBins.length = count;\n\n        // set the candidates\n        var b = 0;\n        for (var c = cStart; c < cEnd; c += 6, b++) {\n          var bin = truncatedBins[b];\n          bin.candidate = triangleBounds[c + 2 * a];\n          bin.count = 0;\n          var bounds = bin.bounds,\n            leftCacheBounds = bin.leftCacheBounds,\n            rightCacheBounds = bin.rightCacheBounds;\n          for (var d = 0; d < 3; d++) {\n            rightCacheBounds[d] = Infinity;\n            rightCacheBounds[d + 3] = -Infinity;\n            leftCacheBounds[d] = Infinity;\n            leftCacheBounds[d + 3] = -Infinity;\n            bounds[d] = Infinity;\n            bounds[d + 3] = -Infinity;\n          }\n          expandByTriangleBounds(c, triangleBounds, bounds);\n        }\n        truncatedBins.sort(binsSort);\n\n        // remove redundant splits\n        var splitCount = count;\n        for (var bi = 0; bi < splitCount; bi++) {\n          var _bin = truncatedBins[bi];\n          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === _bin.candidate) {\n            truncatedBins.splice(bi + 1, 1);\n            splitCount--;\n          }\n        }\n\n        // find the appropriate bin for each triangle and expand the bounds.\n        for (var _c = cStart; _c < cEnd; _c += 6) {\n          var center = triangleBounds[_c + 2 * a];\n          for (var _bi = 0; _bi < splitCount; _bi++) {\n            var _bin2 = truncatedBins[_bi];\n            if (center >= _bin2.candidate) {\n              expandByTriangleBounds(_c, triangleBounds, _bin2.rightCacheBounds);\n            } else {\n              expandByTriangleBounds(_c, triangleBounds, _bin2.leftCacheBounds);\n              _bin2.count++;\n            }\n          }\n        }\n\n        // expand all the bounds\n        for (var _bi2 = 0; _bi2 < splitCount; _bi2++) {\n          var _bin3 = truncatedBins[_bi2];\n          var leftCount = _bin3.count;\n          var rightCount = count - _bin3.count;\n\n          // check the cost of this split\n          var _leftBounds = _bin3.leftCacheBounds;\n          var rightBounds = _bin3.rightCacheBounds;\n          var leftProb = 0;\n          if (leftCount !== 0) {\n            leftProb = computeSurfaceArea(_leftBounds) / rootSurfaceArea;\n          }\n          var rightProb = 0;\n          if (rightCount !== 0) {\n            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;\n          }\n          var cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n          if (cost < bestCost) {\n            axis = a;\n            bestCost = cost;\n            pos = _bin3.candidate;\n          }\n        }\n      } else {\n        // reset the bins\n        for (var i = 0; i < BIN_COUNT; i++) {\n          var _bin4 = sahBins[i];\n          _bin4.count = 0;\n          _bin4.candidate = axisLeft + binWidth + i * binWidth;\n          var _bounds = _bin4.bounds;\n          for (var _d = 0; _d < 3; _d++) {\n            _bounds[_d] = Infinity;\n            _bounds[_d + 3] = -Infinity;\n          }\n        }\n\n        // iterate over all center positions\n        for (var _c2 = cStart; _c2 < cEnd; _c2 += 6) {\n          var triCenter = triangleBounds[_c2 + 2 * a];\n          var relativeCenter = triCenter - axisLeft;\n\n          // in the partition function if the centroid lies on the split plane then it is\n          // considered to be on the right side of the split\n          var binIndex = ~~(relativeCenter / binWidth);\n          if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;\n          var _bin5 = sahBins[binIndex];\n          _bin5.count++;\n          expandByTriangleBounds(_c2, triangleBounds, _bin5.bounds);\n        }\n\n        // cache the unioned bounds from right to left so we don't have to regenerate them each time\n        var lastBin = sahBins[BIN_COUNT - 1];\n        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);\n        for (var _i = BIN_COUNT - 2; _i >= 0; _i--) {\n          var _bin6 = sahBins[_i];\n          var nextBin = sahBins[_i + 1];\n          unionBounds(_bin6.bounds, nextBin.rightCacheBounds, _bin6.rightCacheBounds);\n        }\n        var _leftCount = 0;\n        for (var _i2 = 0; _i2 < BIN_COUNT - 1; _i2++) {\n          var _bin7 = sahBins[_i2];\n          var binCount = _bin7.count;\n          var _bounds2 = _bin7.bounds;\n          var _nextBin = sahBins[_i2 + 1];\n          var _rightBounds = _nextBin.rightCacheBounds;\n\n          // don't do anything with the bounds if the new bounds have no triangles\n          if (binCount !== 0) {\n            if (_leftCount === 0) {\n              copyBounds(_bounds2, leftBounds);\n            } else {\n              unionBounds(_bounds2, leftBounds, leftBounds);\n            }\n          }\n          _leftCount += binCount;\n\n          // check the cost of this split\n          var _leftProb = 0;\n          var _rightProb = 0;\n          if (_leftCount !== 0) {\n            _leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;\n          }\n          var _rightCount = count - _leftCount;\n          if (_rightCount !== 0) {\n            _rightProb = computeSurfaceArea(_rightBounds) / rootSurfaceArea;\n          }\n          var _cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (_leftProb * _leftCount + _rightProb * _rightCount);\n          if (_cost < bestCost) {\n            axis = a;\n            bestCost = _cost;\n            pos = _bin7.candidate;\n          }\n        }\n      }\n    }\n  } else {\n    console.warn(\"MeshBVH: Invalid build strategy value \".concat(strategy, \" used.\"));\n  }\n  return {\n    axis: axis,\n    pos: pos\n  };\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage(triangleBounds, offset, count, axis) {\n  var avg = 0;\n  for (var i = offset, end = offset + count; i < end; i++) {\n    avg += triangleBounds[i * 6 + axis * 2];\n  }\n  return avg / count;\n}","map":{"version":3,"names":["getLongestEdgeIndex","computeSurfaceArea","copyBounds","unionBounds","expandByTriangleBounds","CENTER","AVERAGE","SAH","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","BIN_COUNT","binsSort","a","b","candidate","sahBins","Array","fill","map","count","bounds","Float32Array","rightCacheBounds","leftCacheBounds","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","triangleBounds","offset","strategy","axis","pos","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","axisRight","axisLength","binWidth","truncatedBins","_toConsumableArray","length","c","bin","d","Infinity","sort","splitCount","bi","splice","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","i","triCenter","relativeCenter","binIndex","lastBin","nextBin","binCount","console","warn","concat","avg","end"],"sources":["C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/three-mesh-bvh/src/core/build/splitUtils.js"],"sourcesContent":["import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}