{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { BufferAttribute } from 'three';\nexport function getVertexCount(geo) {\n  return geo.index ? geo.index.count : geo.attributes.position.count;\n}\nexport function getTriCount(geo) {\n  return getVertexCount(geo) / 3;\n}\nexport function getIndexArray(vertexCount) {\n  var BufferConstructor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ArrayBuffer;\n  if (vertexCount > 65535) {\n    return new Uint32Array(new BufferConstructor(4 * vertexCount));\n  } else {\n    return new Uint16Array(new BufferConstructor(2 * vertexCount));\n  }\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex(geo, options) {\n  if (!geo.index) {\n    var vertexCount = geo.attributes.position.count;\n    var BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    var index = getIndexArray(vertexCount, BufferConstructor);\n    geo.setIndex(new BufferAttribute(index, 1));\n    for (var i = 0; i < vertexCount; i++) {\n      index[i] = i;\n    }\n  }\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange(geo) {\n  var triCount = getTriCount(geo);\n  var drawRange = geo.drawRange;\n  var start = drawRange.start / 3;\n  var end = (drawRange.start + drawRange.count) / 3;\n  var offset = Math.max(0, start);\n  var count = Math.min(triCount, end) - offset;\n  return [{\n    offset: Math.floor(offset),\n    count: Math.floor(count)\n  }];\n}\nexport function getRootIndexRanges(geo) {\n  if (!geo.groups || !geo.groups.length) {\n    return getFullGeometryRange(geo);\n  }\n  var ranges = [];\n  var rangeBoundaries = new Set();\n  var drawRange = geo.drawRange;\n  var drawRangeStart = drawRange.start / 3;\n  var drawRangeEnd = (drawRange.start + drawRange.count) / 3;\n  var _iterator = _createForOfIteratorHelper(geo.groups),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var group = _step.value;\n      var groupStart = group.start / 3;\n      var groupEnd = (group.start + group.count) / 3;\n      rangeBoundaries.add(Math.max(drawRangeStart, groupStart));\n      rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));\n    }\n\n    // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var sortedBoundaries = Array.from(rangeBoundaries.values()).sort(function (a, b) {\n    return a - b;\n  });\n  for (var i = 0; i < sortedBoundaries.length - 1; i++) {\n    var start = sortedBoundaries[i];\n    var end = sortedBoundaries[i + 1];\n    ranges.push({\n      offset: Math.floor(start),\n      count: Math.floor(end - start)\n    });\n  }\n  return ranges;\n}\nexport function hasGroupGaps(geometry) {\n  if (geometry.groups.length === 0) {\n    return false;\n  }\n  var vertexCount = getTriCount(geometry);\n  var groups = getRootIndexRanges(geometry).sort(function (a, b) {\n    return a.offset - b.offset;\n  });\n  var finalGroup = groups[groups.length - 1];\n  finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);\n  var total = 0;\n  groups.forEach(function (_ref) {\n    var count = _ref.count;\n    return total += count;\n  });\n  return vertexCount !== total;\n}","map":{"version":3,"names":["BufferAttribute","getVertexCount","geo","index","count","attributes","position","getTriCount","getIndexArray","vertexCount","BufferConstructor","arguments","length","undefined","ArrayBuffer","Uint32Array","Uint16Array","ensureIndex","options","useSharedArrayBuffer","SharedArrayBuffer","setIndex","i","getFullGeometryRange","triCount","drawRange","start","end","offset","Math","max","min","floor","getRootIndexRanges","groups","ranges","rangeBoundaries","Set","drawRangeStart","drawRangeEnd","_iterator","_createForOfIteratorHelper","_step","s","n","done","group","value","groupStart","groupEnd","add","err","e","f","sortedBoundaries","Array","from","values","sort","a","b","push","hasGroupGaps","geometry","finalGroup","total","forEach","_ref"],"sources":["C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/three-mesh-bvh/src/core/build/geometryUtils.js"],"sourcesContent":["import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange( geo ) {\n\n\tconst triCount = getTriCount( geo );\n\tconst drawRange = geo.drawRange;\n\tconst start = drawRange.start / 3;\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( triCount, end ) - offset;\n\treturn [ {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t} ];\n\n}\n\nexport function getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn getFullGeometryRange( geo );\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\n\tconst drawRange = geo.drawRange;\n\tconst drawRangeStart = drawRange.start / 3;\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\tfor ( const group of geo.groups ) {\n\n\t\tconst groupStart = group.start / 3;\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t}\n\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ];\n\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\tranges.push( {\n\t\t\toffset: Math.floor( start ),\n\t\t\tcount: Math.floor( end - start ),\n\t\t} );\n\n\t}\n\n\treturn ranges;\n\n}\n\nexport function hasGroupGaps( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\treturn false;\n\n\t}\n\n\tconst vertexCount = getTriCount( geometry );\n\tconst groups = getRootIndexRanges( geometry )\n\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\tconst finalGroup = groups[ groups.length - 1 ];\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\tlet total = 0;\n\tgroups.forEach( ( { count } ) => total += count );\n\treturn vertexCount !== total;\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}