{"ast":null,"code":"import _objectSpread from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast as _shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint as _closestPointToPoint } from './cast/closestPointToPoint.js';\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit as _refit } from './cast/refit.generated.js';\nimport { raycast as _raycast } from './cast/raycast.generated.js';\nimport { raycastFirst as _raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry as _intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry as _closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\nimport { bvhcast as _bvhcast } from './cast/bvhcast.generated.js';\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { bvhcast_indirect } from './cast/bvhcast_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nvar obb = /* @__PURE__ */new OrientedBox();\nvar tempBox = /* @__PURE__ */new Box3();\nexport var MeshBVH = /*#__PURE__*/function () {\n  function MeshBVH(geometry) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, MeshBVH);\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    }\n\n    // default options\n    options = Object.assign(_defineProperty({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      useSharedArrayBuffer: false,\n      setBoundingBox: true,\n      onProgress: null,\n      indirect: false\n    }, SKIP_GENERATION, false), options);\n    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {\n      throw new Error('MeshBVH: SharedArrayBuffer is not available.');\n    }\n\n    // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n    this.geometry = geometry;\n    this._roots = null;\n    this._indirectBuffer = null;\n    if (!options[SKIP_GENERATION]) {\n      buildPackedTree(this, options);\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    }\n    var _indirectBuffer = this._indirectBuffer;\n    this.resolveTriangleIndex = options.indirect ? function (i) {\n      return _indirectBuffer[i];\n    } : function (i) {\n      return i;\n    };\n  }\n  _createClass(MeshBVH, [{\n    key: \"indirect\",\n    get: function get() {\n      return !!this._indirectBuffer;\n    }\n  }, {\n    key: \"refit\",\n    value: function refit() {\n      var nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var refitFunc = this.indirect ? refit_indirect : _refit;\n      return refitFunc(this, nodeIndices);\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      var rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var buffer = this._roots[rootIndex];\n      var uint32Array = new Uint32Array(buffer);\n      var uint16Array = new Uint16Array(buffer);\n      _traverse(0);\n      function _traverse(node32Index) {\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n        } else {\n          // TODO: use node functions here\n          var left = node32Index + BYTES_PER_NODE / 4;\n          var right = uint32Array[node32Index + 6];\n          var splitAxis = uint32Array[node32Index + 7];\n          var stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n          if (!stopTraversal) {\n            _traverse(left, depth + 1);\n            _traverse(right, depth + 1);\n          }\n        }\n      }\n    }\n\n    /* Core Cast Functions */\n  }, {\n    key: \"raycast\",\n    value: function raycast(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var intersects = [];\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n      var raycastFunc = this.indirect ? raycast_indirect : _raycast;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        var startCount = intersects.length;\n        raycastFunc(this, i, materialSide, ray, intersects);\n        if (isArrayMaterial) {\n          var materialIndex = groups[i].materialIndex;\n          for (var j = startCount, jl = intersects.length; j < jl; j++) {\n            intersects[j].face.materialIndex = materialIndex;\n          }\n        }\n      }\n      return intersects;\n    }\n  }, {\n    key: \"raycastFirst\",\n    value: function raycastFirst(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var closestResult = null;\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n      var raycastFirstFunc = this.indirect ? raycastFirst_indirect : _raycastFirst;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        var result = raycastFirstFunc(this, i, materialSide, ray);\n        if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n          closestResult = result;\n          if (isArrayMaterial) {\n            result.face.materialIndex = groups[i].materialIndex;\n          }\n        }\n      }\n      return closestResult;\n    }\n  }, {\n    key: \"intersectsGeometry\",\n    value: function intersectsGeometry(otherGeometry, geomToMesh) {\n      var result = false;\n      var roots = this._roots;\n      var intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : _intersectsGeometry;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);\n        if (result) {\n          break;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"shapecast\",\n    value: function shapecast(callbacks) {\n      var _this = this;\n      var triangle = ExtendedTrianglePool.getPrimitive();\n      var iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n      var boundsTraverseOrder = callbacks.boundsTraverseOrder,\n        intersectsBounds = callbacks.intersectsBounds,\n        intersectsRange = callbacks.intersectsRange,\n        intersectsTriangle = callbacks.intersectsTriangle;\n\n      // wrap the intersectsRange function\n      if (intersectsRange && intersectsTriangle) {\n        var originalIntersectsRange = intersectsRange;\n        intersectsRange = function intersectsRange(offset, count, contained, depth, nodeIndex) {\n          if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n            return iterateFunc(offset, count, _this, intersectsTriangle, contained, depth, triangle);\n          }\n          return true;\n        };\n      } else if (!intersectsRange) {\n        if (intersectsTriangle) {\n          intersectsRange = function intersectsRange(offset, count, contained, depth) {\n            return iterateFunc(offset, count, _this, intersectsTriangle, contained, depth, triangle);\n          };\n        } else {\n          intersectsRange = function intersectsRange(offset, count, contained) {\n            return contained;\n          };\n        }\n      }\n\n      // run shapecast\n      var result = false;\n      var byteOffset = 0;\n      var roots = this._roots;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var root = roots[i];\n        result = _shapecast(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n        if (result) {\n          break;\n        }\n        byteOffset += root.byteLength;\n      }\n      ExtendedTrianglePool.releasePrimitive(triangle);\n      return result;\n    }\n  }, {\n    key: \"bvhcast\",\n    value: function bvhcast(otherBvh, matrixToLocal, callbacks) {\n      var bvhcastFunc = this.indirect ? bvhcast_indirect : _bvhcast;\n      return bvhcastFunc(this, otherBvh, matrixToLocal, callbacks);\n    }\n\n    /* Derived Cast Functions */\n  }, {\n    key: \"intersectsBox\",\n    value: function intersectsBox(box, boxToMesh) {\n      obb.set(box.min, box.max, boxToMesh);\n      obb.needsUpdate = true;\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return obb.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return obb.intersectsTriangle(tri);\n        }\n      });\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(sphere) {\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return sphere.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return tri.intersectsSphere(sphere);\n        }\n      });\n    }\n  }, {\n    key: \"closestPointToGeometry\",\n    value: function closestPointToGeometry(otherGeometry, geometryToBvh) {\n      var target1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var target2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var minThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var maxThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n      var closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : _closestPointToGeometry;\n      return closestPointToGeometryFunc(this, otherGeometry, geometryToBvh, target1, target2, minThreshold, maxThreshold);\n    }\n  }, {\n    key: \"closestPointToPoint\",\n    value: function closestPointToPoint(point) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var minThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var maxThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      return _closestPointToPoint(this, point, target, minThreshold, maxThreshold);\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(target) {\n      target.makeEmpty();\n      var roots = this._roots;\n      roots.forEach(function (buffer) {\n        arrayToBox(0, new Float32Array(buffer), tempBox);\n        target.union(tempBox);\n      });\n      return target;\n    }\n  }], [{\n    key: \"serialize\",\n    value: function serialize(bvh) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      options = _objectSpread({\n        cloneBuffers: true\n      }, options);\n      var geometry = bvh.geometry;\n      var rootData = bvh._roots;\n      var indirectBuffer = bvh._indirectBuffer;\n      var indexAttribute = geometry.getIndex();\n      var result;\n      if (options.cloneBuffers) {\n        result = {\n          roots: rootData.map(function (root) {\n            return root.slice();\n          }),\n          index: indexAttribute.array.slice(),\n          indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null\n        };\n      } else {\n        result = {\n          roots: rootData,\n          index: indexAttribute.array,\n          indirectBuffer: indirectBuffer\n        };\n      }\n      return result;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, geometry) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      options = _objectSpread({\n        setIndex: true,\n        indirect: Boolean(data.indirectBuffer)\n      }, options);\n      var index = data.index,\n        roots = data.roots,\n        indirectBuffer = data.indirectBuffer;\n      var bvh = new MeshBVH(geometry, _objectSpread(_objectSpread({}, options), {}, _defineProperty({}, SKIP_GENERATION, true)));\n      bvh._roots = roots;\n      bvh._indirectBuffer = indirectBuffer || null;\n      if (options.setIndex) {\n        var indexAttribute = geometry.getIndex();\n        if (indexAttribute === null) {\n          var newIndex = new BufferAttribute(data.index, 1, false);\n          geometry.setIndex(newIndex);\n        } else if (indexAttribute.array !== index) {\n          indexAttribute.array.set(index);\n          indexAttribute.needsUpdate = true;\n        }\n      }\n      return bvh;\n    }\n  }]);\n  return MeshBVH;\n}();","map":{"version":3,"names":["BufferAttribute","Box3","FrontSide","CENTER","BYTES_PER_NODE","IS_LEAFNODE_FLAG","SKIP_GENERATION","buildPackedTree","OrientedBox","arrayToBox","ExtendedTrianglePool","shapecast","closestPointToPoint","iterateOverTriangles","refit","raycast","raycastFirst","intersectsGeometry","closestPointToGeometry","bvhcast","iterateOverTriangles_indirect","refit_indirect","raycast_indirect","raycastFirst_indirect","intersectsGeometry_indirect","closestPointToGeometry_indirect","bvhcast_indirect","isSharedArrayBufferSupported","obb","tempBox","MeshBVH","geometry","options","arguments","length","undefined","_classCallCheck","isBufferGeometry","Error","index","isInterleavedBufferAttribute","Object","assign","_defineProperty","strategy","maxDepth","maxLeafTris","verbose","useSharedArrayBuffer","setBoundingBox","onProgress","indirect","_roots","_indirectBuffer","boundingBox","getBoundingBox","resolveTriangleIndex","i","_createClass","key","get","value","nodeIndices","refitFunc","traverse","callback","rootIndex","buffer","uint32Array","Uint32Array","uint16Array","Uint16Array","_traverse","node32Index","depth","node16Index","isLeaf","offset","count","Float32Array","left","right","splitAxis","stopTraversal","ray","materialOrSide","roots","intersects","isMaterial","isArrayMaterial","Array","isArray","groups","side","raycastFunc","l","materialSide","materialIndex","startCount","j","jl","face","closestResult","raycastFirstFunc","result","distance","otherGeometry","geomToMesh","intersectsGeometryFunc","callbacks","_this","triangle","getPrimitive","iterateFunc","boundsTraverseOrder","intersectsBounds","intersectsRange","intersectsTriangle","originalIntersectsRange","contained","nodeIndex","byteOffset","root","byteLength","releasePrimitive","otherBvh","matrixToLocal","bvhcastFunc","intersectsBox","box","boxToMesh","set","min","max","needsUpdate","tri","intersectsSphere","sphere","geometryToBvh","target1","target2","minThreshold","maxThreshold","Infinity","closestPointToGeometryFunc","point","target","makeEmpty","forEach","union","serialize","bvh","_objectSpread","cloneBuffers","rootData","indirectBuffer","indexAttribute","getIndex","map","slice","array","deserialize","data","setIndex","Boolean","newIndex"],"sources":["C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/three-mesh-bvh/src/core/MeshBVH.js"],"sourcesContent":["import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\nimport { bvhcast } from './cast/bvhcast.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { bvhcast_indirect } from './cast/bvhcast_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute.array,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\tstrategy: CENTER,\n\t\t\tmaxDepth: 40,\n\t\t\tmaxLeafTris: 10,\n\t\t\tverbose: true,\n\t\t\tuseSharedArrayBuffer: false,\n\t\t\tsetBoundingBox: true,\n\t\t\tonProgress: null,\n\t\t\tindirect: false,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst { _indirectBuffer } = this;\n\t\tthis.resolveTriangleIndex = options.indirect ? i => _indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tconst bvhcastFunc = this.indirect ? bvhcast_indirect : bvhcast;\n\t\treturn bvhcastFunc( this, otherBvh, matrixToLocal, callbacks );\n\n\t}\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}