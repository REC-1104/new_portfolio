{"ast":null,"code":"import _slicedToArray from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"startFrame\", \"endFrame\", \"fps\", \"frameName\", \"textureDataURL\", \"textureImageURL\", \"loop\", \"numberOfFrames\", \"autoPlay\", \"animationNames\", \"onStart\", \"onEnd\", \"onLoopEnd\", \"onFrame\", \"play\", \"pause\", \"flipX\", \"alphaTest\", \"children\", \"asSprite\"];\nimport * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nvar SpriteAnimator = function SpriteAnimator(_ref, fref) {\n  var startFrame = _ref.startFrame,\n    endFrame = _ref.endFrame,\n    fps = _ref.fps,\n    frameName = _ref.frameName,\n    textureDataURL = _ref.textureDataURL,\n    textureImageURL = _ref.textureImageURL,\n    loop = _ref.loop,\n    numberOfFrames = _ref.numberOfFrames,\n    autoPlay = _ref.autoPlay,\n    animationNames = _ref.animationNames,\n    onStart = _ref.onStart,\n    onEnd = _ref.onEnd,\n    onLoopEnd = _ref.onLoopEnd,\n    onFrame = _ref.onFrame,\n    play = _ref.play,\n    pause = _ref.pause,\n    flipX = _ref.flipX,\n    alphaTest = _ref.alphaTest,\n    children = _ref.children,\n    asSprite = _ref.asSprite,\n    props = _objectWithoutProperties(_ref, _excluded);\n  useThree(function (state) {\n    return state.viewport;\n  });\n  var spriteData = React.useRef(null);\n  var _React$useState = React.useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    isJsonReady = _React$useState2[0],\n    setJsonReady = _React$useState2[1];\n  var hasEnded = React.useRef(false);\n  var matRef = React.useRef();\n  var spriteRef = React.useRef();\n  var timerOffset = React.useRef(window.performance.now());\n  var textureData = React.useRef();\n  var currentFrame = React.useRef(startFrame || 0);\n  var currentFrameName = React.useRef(frameName || '');\n  var fpsInterval = 1000 / (fps || 30);\n  var _React$useState3 = React.useState(new THREE.Texture()),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    spriteTexture = _React$useState4[0],\n    setSpriteTexture = _React$useState4[1];\n  var totalFrames = React.useRef(0);\n  var _React$useState5 = React.useState([1, 1, 1]),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    aspect = _React$useState6[0],\n    setAspect = _React$useState6[1];\n  var flipOffset = flipX ? -1 : 1;\n  var _React$useState7 = React.useState(asSprite !== null && asSprite !== void 0 ? asSprite : true),\n    _React$useState8 = _slicedToArray(_React$useState7, 2),\n    displayAsSprite = _React$useState8[0],\n    setDisplayAsSprite = _React$useState8[1];\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    var textureLoader = new THREE.TextureLoader();\n    var jsonPromise = fetch(jsonUrl).then(function (response) {\n      return response.json();\n    });\n    var texturePromise = new Promise(function (resolve) {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(function (response) {\n      callback(response[0], response[1]);\n    });\n  }\n  var calculateAspectRatio = function calculateAspectRatio(width, height) {\n    var aspectRatio = height / width;\n    spriteRef.current.scale.set(1, aspectRatio, 1);\n    return [1, aspectRatio, 1];\n  };\n\n  // initial loads\n  React.useEffect(function () {\n    if (textureDataURL && textureImageURL) {\n      loadJsonAndTextureAndExecuteCallback(textureDataURL, textureImageURL, parseSpriteData);\n    } else if (textureImageURL) {\n      // only load the texture, this is an image sprite only\n      var textureLoader = new THREE.TextureLoader();\n      new Promise(function (resolve) {\n        textureLoader.load(textureImageURL, resolve);\n      }).then(function (texture) {\n        parseSpriteData(null, texture);\n      });\n    }\n  }, []);\n  React.useEffect(function () {\n    setDisplayAsSprite(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  }, [asSprite]);\n  React.useLayoutEffect(function () {\n    modifySpritePosition();\n  }, [spriteTexture, flipX]);\n  React.useEffect(function () {}, [pause]);\n  React.useEffect(function () {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      hasEnded.current = false;\n    }\n  }, [frameName]);\n  var parseSpriteData = function parseSpriteData(json, _spriteTexture) {\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        var width = _spriteTexture.image.width;\n        var height = _spriteTexture.image.height;\n        var frameWidth = width / numberOfFrames;\n        var frameHeight = height;\n        textureData.current = _spriteTexture;\n        totalFrames.current = numberOfFrames;\n        spriteData.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        if (parseInt(frameWidth.toString(), 10) === frameWidth) {\n          // if it fits\n          for (var i = 0; i < numberOfFrames; i++) {\n            spriteData.current.frames.push({\n              frame: {\n                x: i * frameWidth,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: height\n              }\n            });\n          }\n        }\n      }\n    } else if (_spriteTexture) {\n      spriteData.current = json;\n      spriteData.current.frames = Array.isArray(json.frames) ? json.frames : parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      textureData.current = _spriteTexture;\n      var _getFirstItem$sourceS = getFirstItem(json.frames).sourceSize,\n        w = _getFirstItem$sourceS.w,\n        h = _getFirstItem$sourceS.h;\n      var _aspect = calculateAspectRatio(w, h);\n      setAspect(_aspect);\n      if (matRef.current) {\n        matRef.current.map = _spriteTexture;\n      }\n    }\n    _spriteTexture.premultiplyAlpha = false;\n    setSpriteTexture(_spriteTexture);\n  };\n\n  // for frame based JSON Hash sprite data\n  var parseFrames = function parseFrames() {\n    var sprites = {};\n    var data = spriteData.current;\n    var delimiters = animationNames;\n    if (delimiters) {\n      for (var i = 0; i < delimiters.length; i++) {\n        sprites[delimiters[i]] = [];\n        for (var innerKey in data['frames']) {\n          var value = data['frames'][innerKey];\n          var frameData = value['frame'];\n          var x = frameData['x'];\n          var y = frameData['y'];\n          var width = frameData['w'];\n          var height = frameData['h'];\n          var sourceWidth = value['sourceSize']['w'];\n          var sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n    }\n    return sprites;\n  };\n\n  // modify the sprite material after json is parsed and state updated\n  var modifySpritePosition = function modifySpritePosition() {\n    if (!spriteData.current) return;\n    var _spriteData$current2 = spriteData.current,\n      metaInfo = _spriteData$current2.meta.size,\n      frames = _spriteData$current2.frames;\n    var _ref2 = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n        w: 0,\n        h: 0\n      } : {\n        w: 0,\n        h: 0\n      },\n      frameW = _ref2.w,\n      frameH = _ref2.h;\n    matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n    matRef.current.map.center.set(0, 0);\n    matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n\n    //const framesH = (metaInfo.w - 1) / frameW\n    var framesV = (metaInfo.h - 1) / frameH;\n    var frameOffsetY = 1 / framesV;\n    matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n    matRef.current.map.offset.y = 1 - frameOffsetY;\n    setJsonReady(true);\n    if (onStart) onStart({\n      currentFrameName: frameName,\n      currentFrame: currentFrame.current\n    });\n  };\n\n  // run the animation on each frame\n  var runAnimation = function runAnimation() {\n    //if (!frameName) return\n    var now = window.performance.now();\n    var diff = now - timerOffset.current;\n    var _spriteData$current3 = spriteData.current,\n      metaInfo = _spriteData$current3.meta.size,\n      frames = _spriteData$current3.frames;\n    var _getFirstItem$sourceS2 = getFirstItem(frames).sourceSize,\n      frameW = _getFirstItem$sourceS2.w,\n      frameH = _getFirstItem$sourceS2.h;\n    var spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    var finalValX = 0;\n    var finalValY = 0;\n    var _endFrame = endFrame || spriteFrames.length - 1;\n    if (currentFrame.current > _endFrame) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        hasEnded.current = true;\n      }\n      if (!loop) return;\n    }\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateAspectRatio(frameW, frameH);\n    var framesH = (metaInfo.w - 1) / frameW;\n    var framesV = (metaInfo.h - 1) / frameH;\n    var _spriteFrames$current = spriteFrames[currentFrame.current],\n      _spriteFrames$current2 = _spriteFrames$current.frame,\n      frameX = _spriteFrames$current2.x,\n      frameY = _spriteFrames$current2.y,\n      _spriteFrames$current3 = _spriteFrames$current.sourceSize,\n      originalSizeX = _spriteFrames$current3.w,\n      originalSizeY = _spriteFrames$current3.h;\n    var frameOffsetX = 1 / framesH;\n    var frameOffsetY = 1 / framesV;\n    finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n    finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n    matRef.current.map.offset.x = finalValX;\n    matRef.current.map.offset.y = finalValY;\n    currentFrame.current += 1;\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame(function (state, delta) {\n    var _spriteData$current, _matRef$current;\n    if (!((_spriteData$current = spriteData.current) != null && _spriteData$current.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pause) {\n      return;\n    }\n    if (!hasEnded.current && (autoPlay || play)) {\n      runAnimation();\n      onFrame && onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n\n  // utils\n  var getFirstItem = function getFirstItem(param) {\n    if (Array.isArray(param)) {\n      return param[0];\n    } else if (typeof param === 'object' && param !== null) {\n      var keys = Object.keys(param);\n      return param[keys[0]][0];\n    } else {\n      return {\n        w: 0,\n        h: 0\n      };\n    }\n  };\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback: null\n  }, displayAsSprite && /*#__PURE__*/React.createElement(\"sprite\", {\n    ref: spriteRef,\n    scale: aspect\n  }, /*#__PURE__*/React.createElement(\"spriteMaterial\", {\n    toneMapped: false,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  })), !displayAsSprite && /*#__PURE__*/React.createElement(\"mesh\", {\n    ref: spriteRef,\n    scale: aspect\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: [1, 1]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }))), children);\n};\nexport { SpriteAnimator };","map":{"version":3,"names":["React","useThree","useFrame","THREE","SpriteAnimator","_ref","fref","startFrame","endFrame","fps","frameName","textureDataURL","textureImageURL","loop","numberOfFrames","autoPlay","animationNames","onStart","onEnd","onLoopEnd","onFrame","play","pause","flipX","alphaTest","children","asSprite","props","_objectWithoutProperties","_excluded","state","viewport","spriteData","useRef","_React$useState","useState","_React$useState2","_slicedToArray","isJsonReady","setJsonReady","hasEnded","matRef","spriteRef","timerOffset","window","performance","now","textureData","currentFrame","currentFrameName","fpsInterval","_React$useState3","Texture","_React$useState4","spriteTexture","setSpriteTexture","totalFrames","_React$useState5","_React$useState6","aspect","setAspect","flipOffset","_React$useState7","_React$useState8","displayAsSprite","setDisplayAsSprite","loadJsonAndTextureAndExecuteCallback","jsonUrl","textureUrl","callback","textureLoader","TextureLoader","jsonPromise","fetch","then","response","json","texturePromise","Promise","resolve","load","all","calculateAspectRatio","width","height","aspectRatio","current","scale","set","useEffect","parseSpriteData","texture","useLayoutEffect","modifySpritePosition","_spriteTexture","image","frameWidth","frameHeight","frames","meta","version","size","w","h","parseInt","toString","i","push","frame","x","y","rotated","trimmed","spriteSourceSize","sourceSize","Array","isArray","parseFrames","length","Object","keys","_getFirstItem$sourceS","getFirstItem","map","premultiplyAlpha","sprites","data","delimiters","innerKey","value","frameData","sourceWidth","sourceHeight","toLowerCase","indexOf","_spriteData$current2","metaInfo","_ref2","frameW","frameH","wrapS","wrapT","RepeatWrapping","center","repeat","framesV","frameOffsetY","offset","runAnimation","diff","_spriteData$current3","_getFirstItem$sourceS2","spriteFrames","finalValX","finalValY","_endFrame","framesH","_spriteFrames$current","_spriteFrames$current2","frameX","frameY","_spriteFrames$current3","originalSizeX","originalSizeY","frameOffsetX","Math","abs","delta","_spriteData$current","_matRef$current","param","createElement","Suspense","fallback","ref","toneMapped","transparent","args","side","DoubleSide"],"sources":["C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@react-three/drei/core/SpriteAnimator.js"],"sourcesContent":["import * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\n\nconst SpriteAnimator = ({\n  startFrame,\n  endFrame,\n  fps,\n  frameName,\n  textureDataURL,\n  textureImageURL,\n  loop,\n  numberOfFrames,\n  autoPlay,\n  animationNames,\n  onStart,\n  onEnd,\n  onLoopEnd,\n  onFrame,\n  play,\n  pause,\n  flipX,\n  alphaTest,\n  children,\n  asSprite,\n  ...props\n}, fref) => {\n  useThree(state => state.viewport);\n  const spriteData = React.useRef(null);\n  const [isJsonReady, setJsonReady] = React.useState(false);\n  const hasEnded = React.useRef(false);\n  const matRef = React.useRef();\n  const spriteRef = React.useRef();\n  const timerOffset = React.useRef(window.performance.now());\n  const textureData = React.useRef();\n  const currentFrame = React.useRef(startFrame || 0);\n  const currentFrameName = React.useRef(frameName || '');\n  const fpsInterval = 1000 / (fps || 30);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const totalFrames = React.useRef(0);\n  const [aspect, setAspect] = React.useState([1, 1, 1]);\n  const flipOffset = flipX ? -1 : 1;\n  const [displayAsSprite, setDisplayAsSprite] = React.useState(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const textureLoader = new THREE.TextureLoader();\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const calculateAspectRatio = (width, height) => {\n    const aspectRatio = height / width;\n    spriteRef.current.scale.set(1, aspectRatio, 1);\n    return [1, aspectRatio, 1];\n  };\n\n  // initial loads\n  React.useEffect(() => {\n    if (textureDataURL && textureImageURL) {\n      loadJsonAndTextureAndExecuteCallback(textureDataURL, textureImageURL, parseSpriteData);\n    } else if (textureImageURL) {\n      // only load the texture, this is an image sprite only\n      const textureLoader = new THREE.TextureLoader();\n      new Promise(resolve => {\n        textureLoader.load(textureImageURL, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }, []);\n  React.useEffect(() => {\n    setDisplayAsSprite(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  }, [asSprite]);\n  React.useLayoutEffect(() => {\n    modifySpritePosition();\n  }, [spriteTexture, flipX]);\n  React.useEffect(() => {\n  }, [pause]);\n  React.useEffect(() => {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      hasEnded.current = false;\n    }\n  }, [frameName]);\n  const parseSpriteData = (json, _spriteTexture) => {\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        const frameWidth = width / numberOfFrames;\n        const frameHeight = height;\n        textureData.current = _spriteTexture;\n        totalFrames.current = numberOfFrames;\n        spriteData.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        if (parseInt(frameWidth.toString(), 10) === frameWidth) {\n          // if it fits\n          for (let i = 0; i < numberOfFrames; i++) {\n            spriteData.current.frames.push({\n              frame: {\n                x: i * frameWidth,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: height\n              }\n            });\n          }\n        }\n      }\n    } else if (_spriteTexture) {\n      spriteData.current = json;\n      spriteData.current.frames = Array.isArray(json.frames) ? json.frames : parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      textureData.current = _spriteTexture;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      const aspect = calculateAspectRatio(w, h);\n      setAspect(aspect);\n      if (matRef.current) {\n        matRef.current.map = _spriteTexture;\n      }\n    }\n    _spriteTexture.premultiplyAlpha = false;\n    setSpriteTexture(_spriteTexture);\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteData.current;\n    const delimiters = animationNames;\n    if (delimiters) {\n      for (let i = 0; i < delimiters.length; i++) {\n        sprites[delimiters[i]] = [];\n        for (let innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n    }\n    return sprites;\n  };\n\n  // modify the sprite material after json is parsed and state updated\n  const modifySpritePosition = () => {\n    if (!spriteData.current) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n      w: 0,\n      h: 0\n    } : {\n      w: 0,\n      h: 0\n    };\n    matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n    matRef.current.map.center.set(0, 0);\n    matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n\n    //const framesH = (metaInfo.w - 1) / frameW\n    const framesV = (metaInfo.h - 1) / frameH;\n    const frameOffsetY = 1 / framesV;\n    matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n    matRef.current.map.offset.y = 1 - frameOffsetY;\n    setJsonReady(true);\n    if (onStart) onStart({\n      currentFrameName: frameName,\n      currentFrame: currentFrame.current\n    });\n  };\n\n  // run the animation on each frame\n  const runAnimation = () => {\n    //if (!frameName) return\n    const now = window.performance.now();\n    const diff = now - timerOffset.current;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = getFirstItem(frames).sourceSize;\n    const spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    let finalValX = 0;\n    let finalValY = 0;\n    const _endFrame = endFrame || spriteFrames.length - 1;\n    if (currentFrame.current > _endFrame) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        hasEnded.current = true;\n      }\n      if (!loop) return;\n    }\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateAspectRatio(frameW, frameH);\n    const framesH = (metaInfo.w - 1) / frameW;\n    const framesV = (metaInfo.h - 1) / frameH;\n    const {\n      frame: {\n        x: frameX,\n        y: frameY\n      },\n      sourceSize: {\n        w: originalSizeX,\n        h: originalSizeY\n      }\n    } = spriteFrames[currentFrame.current];\n    const frameOffsetX = 1 / framesH;\n    const frameOffsetY = 1 / framesV;\n    finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n    finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n    matRef.current.map.offset.x = finalValX;\n    matRef.current.map.offset.y = finalValY;\n    currentFrame.current += 1;\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame((state, delta) => {\n    var _spriteData$current, _matRef$current;\n    if (!((_spriteData$current = spriteData.current) != null && _spriteData$current.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pause) {\n      return;\n    }\n    if (!hasEnded.current && (autoPlay || play)) {\n      runAnimation();\n      onFrame && onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n\n  // utils\n  const getFirstItem = param => {\n    if (Array.isArray(param)) {\n      return param[0];\n    } else if (typeof param === 'object' && param !== null) {\n      const keys = Object.keys(param);\n      return param[keys[0]][0];\n    } else {\n      return {\n        w: 0,\n        h: 0\n      };\n    }\n  };\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback: null\n  }, displayAsSprite && /*#__PURE__*/React.createElement(\"sprite\", {\n    ref: spriteRef,\n    scale: aspect\n  }, /*#__PURE__*/React.createElement(\"spriteMaterial\", {\n    toneMapped: false,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  })), !displayAsSprite && /*#__PURE__*/React.createElement(\"mesh\", {\n    ref: spriteRef,\n    scale: aspect\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: [1, 1]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }))), children);\n};\n\nexport { SpriteAnimator };\n"],"mappings":";;;AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,QAAQ,EAAEC,QAAQ,QAAQ,oBAAoB;AACvD,OAAO,KAAKC,KAAK,MAAM,OAAO;AAE9B,IAAMC,cAAc,GAAG,SAAjBA,cAAcA,CAAAC,IAAA,EAsBjBC,IAAI,EAAK;EAAA,IArBVC,UAAU,GAAAF,IAAA,CAAVE,UAAU;IACVC,QAAQ,GAAAH,IAAA,CAARG,QAAQ;IACRC,GAAG,GAAAJ,IAAA,CAAHI,GAAG;IACHC,SAAS,GAAAL,IAAA,CAATK,SAAS;IACTC,cAAc,GAAAN,IAAA,CAAdM,cAAc;IACdC,eAAe,GAAAP,IAAA,CAAfO,eAAe;IACfC,IAAI,GAAAR,IAAA,CAAJQ,IAAI;IACJC,cAAc,GAAAT,IAAA,CAAdS,cAAc;IACdC,QAAQ,GAAAV,IAAA,CAARU,QAAQ;IACRC,cAAc,GAAAX,IAAA,CAAdW,cAAc;IACdC,OAAO,GAAAZ,IAAA,CAAPY,OAAO;IACPC,KAAK,GAAAb,IAAA,CAALa,KAAK;IACLC,SAAS,GAAAd,IAAA,CAATc,SAAS;IACTC,OAAO,GAAAf,IAAA,CAAPe,OAAO;IACPC,IAAI,GAAAhB,IAAA,CAAJgB,IAAI;IACJC,KAAK,GAAAjB,IAAA,CAALiB,KAAK;IACLC,KAAK,GAAAlB,IAAA,CAALkB,KAAK;IACLC,SAAS,GAAAnB,IAAA,CAATmB,SAAS;IACTC,QAAQ,GAAApB,IAAA,CAARoB,QAAQ;IACRC,QAAQ,GAAArB,IAAA,CAARqB,QAAQ;IACLC,KAAK,GAAAC,wBAAA,CAAAvB,IAAA,EAAAwB,SAAA;EAER5B,QAAQ,CAAC,UAAA6B,KAAK;IAAA,OAAIA,KAAK,CAACC,QAAQ;EAAA,EAAC;EACjC,IAAMC,UAAU,GAAGhC,KAAK,CAACiC,MAAM,CAAC,IAAI,CAAC;EACrC,IAAAC,eAAA,GAAoClC,KAAK,CAACmC,QAAQ,CAAC,KAAK,CAAC;IAAAC,gBAAA,GAAAC,cAAA,CAAAH,eAAA;IAAlDI,WAAW,GAAAF,gBAAA;IAAEG,YAAY,GAAAH,gBAAA;EAChC,IAAMI,QAAQ,GAAGxC,KAAK,CAACiC,MAAM,CAAC,KAAK,CAAC;EACpC,IAAMQ,MAAM,GAAGzC,KAAK,CAACiC,MAAM,CAAC,CAAC;EAC7B,IAAMS,SAAS,GAAG1C,KAAK,CAACiC,MAAM,CAAC,CAAC;EAChC,IAAMU,WAAW,GAAG3C,KAAK,CAACiC,MAAM,CAACW,MAAM,CAACC,WAAW,CAACC,GAAG,CAAC,CAAC,CAAC;EAC1D,IAAMC,WAAW,GAAG/C,KAAK,CAACiC,MAAM,CAAC,CAAC;EAClC,IAAMe,YAAY,GAAGhD,KAAK,CAACiC,MAAM,CAAC1B,UAAU,IAAI,CAAC,CAAC;EAClD,IAAM0C,gBAAgB,GAAGjD,KAAK,CAACiC,MAAM,CAACvB,SAAS,IAAI,EAAE,CAAC;EACtD,IAAMwC,WAAW,GAAG,IAAI,IAAIzC,GAAG,IAAI,EAAE,CAAC;EACtC,IAAA0C,gBAAA,GAA0CnD,KAAK,CAACmC,QAAQ,CAAC,IAAIhC,KAAK,CAACiD,OAAO,CAAC,CAAC,CAAC;IAAAC,gBAAA,GAAAhB,cAAA,CAAAc,gBAAA;IAAtEG,aAAa,GAAAD,gBAAA;IAAEE,gBAAgB,GAAAF,gBAAA;EACtC,IAAMG,WAAW,GAAGxD,KAAK,CAACiC,MAAM,CAAC,CAAC,CAAC;EACnC,IAAAwB,gBAAA,GAA4BzD,KAAK,CAACmC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAAAuB,gBAAA,GAAArB,cAAA,CAAAoB,gBAAA;IAA9CE,MAAM,GAAAD,gBAAA;IAAEE,SAAS,GAAAF,gBAAA;EACxB,IAAMG,UAAU,GAAGtC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC;EACjC,IAAAuC,gBAAA,GAA8C9D,KAAK,CAACmC,QAAQ,CAACT,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAGA,QAAQ,GAAG,IAAI,CAAC;IAAAqC,gBAAA,GAAA1B,cAAA,CAAAyB,gBAAA;IAAjHE,eAAe,GAAAD,gBAAA;IAAEE,kBAAkB,GAAAF,gBAAA;EAC1C,SAASG,oCAAoCA,CAACC,OAAO,EAAEC,UAAU,EAAEC,QAAQ,EAAE;IAC3E,IAAMC,aAAa,GAAG,IAAInE,KAAK,CAACoE,aAAa,CAAC,CAAC;IAC/C,IAAMC,WAAW,GAAGC,KAAK,CAACN,OAAO,CAAC,CAACO,IAAI,CAAC,UAAAC,QAAQ;MAAA,OAAIA,QAAQ,CAACC,IAAI,CAAC,CAAC;IAAA,EAAC;IACpE,IAAMC,cAAc,GAAG,IAAIC,OAAO,CAAC,UAAAC,OAAO,EAAI;MAC5CT,aAAa,CAACU,IAAI,CAACZ,UAAU,EAAEW,OAAO,CAAC;IACzC,CAAC,CAAC;IACFD,OAAO,CAACG,GAAG,CAAC,CAACT,WAAW,EAAEK,cAAc,CAAC,CAAC,CAACH,IAAI,CAAC,UAAAC,QAAQ,EAAI;MAC1DN,QAAQ,CAACM,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC;IACpC,CAAC,CAAC;EACJ;EACA,IAAMO,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAIC,KAAK,EAAEC,MAAM,EAAK;IAC9C,IAAMC,WAAW,GAAGD,MAAM,GAAGD,KAAK;IAClCzC,SAAS,CAAC4C,OAAO,CAACC,KAAK,CAACC,GAAG,CAAC,CAAC,EAAEH,WAAW,EAAE,CAAC,CAAC;IAC9C,OAAO,CAAC,CAAC,EAAEA,WAAW,EAAE,CAAC,CAAC;EAC5B,CAAC;;EAED;EACArF,KAAK,CAACyF,SAAS,CAAC,YAAM;IACpB,IAAI9E,cAAc,IAAIC,eAAe,EAAE;MACrCsD,oCAAoC,CAACvD,cAAc,EAAEC,eAAe,EAAE8E,eAAe,CAAC;IACxF,CAAC,MAAM,IAAI9E,eAAe,EAAE;MAC1B;MACA,IAAM0D,aAAa,GAAG,IAAInE,KAAK,CAACoE,aAAa,CAAC,CAAC;MAC/C,IAAIO,OAAO,CAAC,UAAAC,OAAO,EAAI;QACrBT,aAAa,CAACU,IAAI,CAACpE,eAAe,EAAEmE,OAAO,CAAC;MAC9C,CAAC,CAAC,CAACL,IAAI,CAAC,UAAAiB,OAAO,EAAI;QACjBD,eAAe,CAAC,IAAI,EAAEC,OAAO,CAAC;MAChC,CAAC,CAAC;IACJ;EACF,CAAC,EAAE,EAAE,CAAC;EACN3F,KAAK,CAACyF,SAAS,CAAC,YAAM;IACpBxB,kBAAkB,CAACvC,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAGA,QAAQ,GAAG,IAAI,CAAC;EAChF,CAAC,EAAE,CAACA,QAAQ,CAAC,CAAC;EACd1B,KAAK,CAAC4F,eAAe,CAAC,YAAM;IAC1BC,oBAAoB,CAAC,CAAC;EACxB,CAAC,EAAE,CAACvC,aAAa,EAAE/B,KAAK,CAAC,CAAC;EAC1BvB,KAAK,CAACyF,SAAS,CAAC,YAAM,CACtB,CAAC,EAAE,CAACnE,KAAK,CAAC,CAAC;EACXtB,KAAK,CAACyF,SAAS,CAAC,YAAM;IACpB,IAAIxC,gBAAgB,CAACqC,OAAO,KAAK5E,SAAS,IAAIA,SAAS,EAAE;MACvDsC,YAAY,CAACsC,OAAO,GAAG,CAAC;MACxBrC,gBAAgB,CAACqC,OAAO,GAAG5E,SAAS;MACpC8B,QAAQ,CAAC8C,OAAO,GAAG,KAAK;IAC1B;EACF,CAAC,EAAE,CAAC5E,SAAS,CAAC,CAAC;EACf,IAAMgF,eAAe,GAAG,SAAlBA,eAAeA,CAAId,IAAI,EAAEkB,cAAc,EAAK;IAChD;IACA,IAAIlB,IAAI,KAAK,IAAI,EAAE;MACjB,IAAIkB,cAAc,IAAIhF,cAAc,EAAE;QACpC;QACA,IAAMqE,KAAK,GAAGW,cAAc,CAACC,KAAK,CAACZ,KAAK;QACxC,IAAMC,MAAM,GAAGU,cAAc,CAACC,KAAK,CAACX,MAAM;QAC1C,IAAMY,UAAU,GAAGb,KAAK,GAAGrE,cAAc;QACzC,IAAMmF,WAAW,GAAGb,MAAM;QAC1BrC,WAAW,CAACuC,OAAO,GAAGQ,cAAc;QACpCtC,WAAW,CAAC8B,OAAO,GAAGxE,cAAc;QACpCkB,UAAU,CAACsD,OAAO,GAAG;UACnBY,MAAM,EAAE,EAAE;UACVC,IAAI,EAAE;YACJC,OAAO,EAAE,KAAK;YACdC,IAAI,EAAE;cACJC,CAAC,EAAEnB,KAAK;cACRoB,CAAC,EAAEnB;YACL,CAAC;YACDG,KAAK,EAAE;UACT;QACF,CAAC;QACD,IAAIiB,QAAQ,CAACR,UAAU,CAACS,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,KAAKT,UAAU,EAAE;UACtD;UACA,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5F,cAAc,EAAE4F,CAAC,EAAE,EAAE;YACvC1E,UAAU,CAACsD,OAAO,CAACY,MAAM,CAACS,IAAI,CAAC;cAC7BC,KAAK,EAAE;gBACLC,CAAC,EAAEH,CAAC,GAAGV,UAAU;gBACjBc,CAAC,EAAE,CAAC;gBACJR,CAAC,EAAEN,UAAU;gBACbO,CAAC,EAAEN;cACL,CAAC;cACDc,OAAO,EAAE,KAAK;cACdC,OAAO,EAAE,KAAK;cACdC,gBAAgB,EAAE;gBAChBJ,CAAC,EAAE,CAAC;gBACJC,CAAC,EAAE,CAAC;gBACJR,CAAC,EAAEN,UAAU;gBACbO,CAAC,EAAEN;cACL,CAAC;cACDiB,UAAU,EAAE;gBACVZ,CAAC,EAAEN,UAAU;gBACbO,CAAC,EAAEnB;cACL;YACF,CAAC,CAAC;UACJ;QACF;MACF;IACF,CAAC,MAAM,IAAIU,cAAc,EAAE;MACzB9D,UAAU,CAACsD,OAAO,GAAGV,IAAI;MACzB5C,UAAU,CAACsD,OAAO,CAACY,MAAM,GAAGiB,KAAK,CAACC,OAAO,CAACxC,IAAI,CAACsB,MAAM,CAAC,GAAGtB,IAAI,CAACsB,MAAM,GAAGmB,WAAW,CAAC,CAAC;MACpF7D,WAAW,CAAC8B,OAAO,GAAG6B,KAAK,CAACC,OAAO,CAACxC,IAAI,CAACsB,MAAM,CAAC,GAAGtB,IAAI,CAACsB,MAAM,CAACoB,MAAM,GAAGC,MAAM,CAACC,IAAI,CAAC5C,IAAI,CAACsB,MAAM,CAAC,CAACoB,MAAM;MACvGvE,WAAW,CAACuC,OAAO,GAAGQ,cAAc;MACpC,IAAA2B,qBAAA,GAGIC,YAAY,CAAC9C,IAAI,CAACsB,MAAM,CAAC,CAACgB,UAAU;QAFtCZ,CAAC,GAAAmB,qBAAA,CAADnB,CAAC;QACDC,CAAC,GAAAkB,qBAAA,CAADlB,CAAC;MAEH,IAAM5C,OAAM,GAAGuB,oBAAoB,CAACoB,CAAC,EAAEC,CAAC,CAAC;MACzC3C,SAAS,CAACD,OAAM,CAAC;MACjB,IAAIlB,MAAM,CAAC6C,OAAO,EAAE;QAClB7C,MAAM,CAAC6C,OAAO,CAACqC,GAAG,GAAG7B,cAAc;MACrC;IACF;IACAA,cAAc,CAAC8B,gBAAgB,GAAG,KAAK;IACvCrE,gBAAgB,CAACuC,cAAc,CAAC;EAClC,CAAC;;EAED;EACA,IAAMuB,WAAW,GAAG,SAAdA,WAAWA,CAAA,EAAS;IACxB,IAAMQ,OAAO,GAAG,CAAC,CAAC;IAClB,IAAMC,IAAI,GAAG9F,UAAU,CAACsD,OAAO;IAC/B,IAAMyC,UAAU,GAAG/G,cAAc;IACjC,IAAI+G,UAAU,EAAE;MACd,KAAK,IAAIrB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,UAAU,CAACT,MAAM,EAAEZ,CAAC,EAAE,EAAE;QAC1CmB,OAAO,CAACE,UAAU,CAACrB,CAAC,CAAC,CAAC,GAAG,EAAE;QAC3B,KAAK,IAAIsB,QAAQ,IAAIF,IAAI,CAAC,QAAQ,CAAC,EAAE;UACnC,IAAMG,KAAK,GAAGH,IAAI,CAAC,QAAQ,CAAC,CAACE,QAAQ,CAAC;UACtC,IAAME,SAAS,GAAGD,KAAK,CAAC,OAAO,CAAC;UAChC,IAAMpB,CAAC,GAAGqB,SAAS,CAAC,GAAG,CAAC;UACxB,IAAMpB,CAAC,GAAGoB,SAAS,CAAC,GAAG,CAAC;UACxB,IAAM/C,KAAK,GAAG+C,SAAS,CAAC,GAAG,CAAC;UAC5B,IAAM9C,MAAM,GAAG8C,SAAS,CAAC,GAAG,CAAC;UAC7B,IAAMC,WAAW,GAAGF,KAAK,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC;UAC5C,IAAMG,YAAY,GAAGH,KAAK,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC;UAC7C,IAAI,OAAOD,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,CAACK,WAAW,CAAC,CAAC,CAACC,OAAO,CAACP,UAAU,CAACrB,CAAC,CAAC,CAAC2B,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;YACtGR,OAAO,CAACE,UAAU,CAACrB,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC;cAC1BE,CAAC,EAAEA,CAAC;cACJC,CAAC,EAAEA,CAAC;cACJR,CAAC,EAAEnB,KAAK;cACRoB,CAAC,EAAEnB,MAAM;cACTwB,KAAK,EAAEsB,SAAS;cAChBhB,UAAU,EAAE;gBACVZ,CAAC,EAAE6B,WAAW;gBACd5B,CAAC,EAAE6B;cACL;YACF,CAAC,CAAC;UACJ;QACF;MACF;IACF;IACA,OAAOP,OAAO;EAChB,CAAC;;EAED;EACA,IAAMhC,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAA,EAAS;IACjC,IAAI,CAAC7D,UAAU,CAACsD,OAAO,EAAE;IACzB,IAAAiD,oBAAA,GAKIvG,UAAU,CAACsD,OAAO;MAHZkD,QAAQ,GAAAD,oBAAA,CADhBpC,IAAI,CACFE,IAAI;MAENH,MAAM,GAAAqC,oBAAA,CAANrC,MAAM;IAER,IAAAuC,KAAA,GAGItB,KAAK,CAACC,OAAO,CAAClB,MAAM,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,CAACgB,UAAU,GAAGxG,SAAS,GAAGwF,MAAM,CAACxF,SAAS,CAAC,GAAGwF,MAAM,CAACxF,SAAS,CAAC,CAAC,CAAC,CAAC,CAACwG,UAAU,GAAG;QACnHZ,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE;MACL,CAAC,GAAG;QACFD,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE;MACL,CAAC;MARImC,MAAM,GAAAD,KAAA,CAATnC,CAAC;MACEqC,MAAM,GAAAF,KAAA,CAATlC,CAAC;IAQH9D,MAAM,CAAC6C,OAAO,CAACqC,GAAG,CAACiB,KAAK,GAAGnG,MAAM,CAAC6C,OAAO,CAACqC,GAAG,CAACkB,KAAK,GAAG1I,KAAK,CAAC2I,cAAc;IAC1ErG,MAAM,CAAC6C,OAAO,CAACqC,GAAG,CAACoB,MAAM,CAACvD,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;IACnC/C,MAAM,CAAC6C,OAAO,CAACqC,GAAG,CAACqB,MAAM,CAACxD,GAAG,CAAC,CAAC,GAAG3B,UAAU,IAAI2E,QAAQ,CAAClC,CAAC,GAAGoC,MAAM,CAAC,EAAE,CAAC,IAAIF,QAAQ,CAACjC,CAAC,GAAGoC,MAAM,CAAC,CAAC;;IAEhG;IACA,IAAMM,OAAO,GAAG,CAACT,QAAQ,CAACjC,CAAC,GAAG,CAAC,IAAIoC,MAAM;IACzC,IAAMO,YAAY,GAAG,CAAC,GAAGD,OAAO;IAChCxG,MAAM,CAAC6C,OAAO,CAACqC,GAAG,CAACwB,MAAM,CAACtC,CAAC,GAAG,GAAG,CAAC,CAAC;IACnCpE,MAAM,CAAC6C,OAAO,CAACqC,GAAG,CAACwB,MAAM,CAACrC,CAAC,GAAG,CAAC,GAAGoC,YAAY;IAC9C3G,YAAY,CAAC,IAAI,CAAC;IAClB,IAAItB,OAAO,EAAEA,OAAO,CAAC;MACnBgC,gBAAgB,EAAEvC,SAAS;MAC3BsC,YAAY,EAAEA,YAAY,CAACsC;IAC7B,CAAC,CAAC;EACJ,CAAC;;EAED;EACA,IAAM8D,YAAY,GAAG,SAAfA,YAAYA,CAAA,EAAS;IACzB;IACA,IAAMtG,GAAG,GAAGF,MAAM,CAACC,WAAW,CAACC,GAAG,CAAC,CAAC;IACpC,IAAMuG,IAAI,GAAGvG,GAAG,GAAGH,WAAW,CAAC2C,OAAO;IACtC,IAAAgE,oBAAA,GAKItH,UAAU,CAACsD,OAAO;MAHZkD,QAAQ,GAAAc,oBAAA,CADhBnD,IAAI,CACFE,IAAI;MAENH,MAAM,GAAAoD,oBAAA,CAANpD,MAAM;IAER,IAAAqD,sBAAA,GAGI7B,YAAY,CAACxB,MAAM,CAAC,CAACgB,UAAU;MAF9BwB,MAAM,GAAAa,sBAAA,CAATjD,CAAC;MACEqC,MAAM,GAAAY,sBAAA,CAAThD,CAAC;IAEH,IAAMiD,YAAY,GAAGrC,KAAK,CAACC,OAAO,CAAClB,MAAM,CAAC,GAAGA,MAAM,GAAGxF,SAAS,GAAGwF,MAAM,CAACxF,SAAS,CAAC,GAAG,EAAE;IACxF,IAAI+I,SAAS,GAAG,CAAC;IACjB,IAAIC,SAAS,GAAG,CAAC;IACjB,IAAMC,SAAS,GAAGnJ,QAAQ,IAAIgJ,YAAY,CAAClC,MAAM,GAAG,CAAC;IACrD,IAAItE,YAAY,CAACsC,OAAO,GAAGqE,SAAS,EAAE;MACpC3G,YAAY,CAACsC,OAAO,GAAGzE,IAAI,GAAGN,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAGA,UAAU,GAAG,CAAC,GAAG,CAAC;MAC/F,IAAIM,IAAI,EAAE;QACRM,SAAS,IAAI,IAAI,IAAIA,SAAS,CAAC;UAC7B8B,gBAAgB,EAAEvC,SAAS;UAC3BsC,YAAY,EAAEA,YAAY,CAACsC;QAC7B,CAAC,CAAC;MACJ,CAAC,MAAM;QACLpE,KAAK,IAAI,IAAI,IAAIA,KAAK,CAAC;UACrB+B,gBAAgB,EAAEvC,SAAS;UAC3BsC,YAAY,EAAEA,YAAY,CAACsC;QAC7B,CAAC,CAAC;QACF9C,QAAQ,CAAC8C,OAAO,GAAG,IAAI;MACzB;MACA,IAAI,CAACzE,IAAI,EAAE;IACb;IACA,IAAIwI,IAAI,IAAInG,WAAW,EAAE;IACzBP,WAAW,CAAC2C,OAAO,GAAGxC,GAAG,GAAGuG,IAAI,GAAGnG,WAAW;IAC9CgC,oBAAoB,CAACwD,MAAM,EAAEC,MAAM,CAAC;IACpC,IAAMiB,OAAO,GAAG,CAACpB,QAAQ,CAAClC,CAAC,GAAG,CAAC,IAAIoC,MAAM;IACzC,IAAMO,OAAO,GAAG,CAACT,QAAQ,CAACjC,CAAC,GAAG,CAAC,IAAIoC,MAAM;IACzC,IAAAkB,qBAAA,GASIL,YAAY,CAACxG,YAAY,CAACsC,OAAO,CAAC;MAAAwE,sBAAA,GAAAD,qBAAA,CARpCjD,KAAK;MACAmD,MAAM,GAAAD,sBAAA,CAATjD,CAAC;MACEmD,MAAM,GAAAF,sBAAA,CAAThD,CAAC;MAAAmD,sBAAA,GAAAJ,qBAAA,CAEH3C,UAAU;MACLgD,aAAa,GAAAD,sBAAA,CAAhB3D,CAAC;MACE6D,aAAa,GAAAF,sBAAA,CAAhB1D,CAAC;IAGL,IAAM6D,YAAY,GAAG,CAAC,GAAGR,OAAO;IAChC,IAAMV,YAAY,GAAG,CAAC,GAAGD,OAAO;IAChCQ,SAAS,GAAG5F,UAAU,GAAG,CAAC,GAAGuG,YAAY,IAAIL,MAAM,GAAGG,aAAa,CAAC,GAAGE,YAAY,IAAIL,MAAM,GAAGG,aAAa,CAAC,GAAGzH,MAAM,CAAC6C,OAAO,CAACqC,GAAG,CAACqB,MAAM,CAACnC,CAAC;IAC5I6C,SAAS,GAAGW,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGpB,YAAY,CAAC,GAAGA,YAAY,IAAIc,MAAM,GAAGG,aAAa,CAAC;IAChF1H,MAAM,CAAC6C,OAAO,CAACqC,GAAG,CAACwB,MAAM,CAACtC,CAAC,GAAG4C,SAAS;IACvChH,MAAM,CAAC6C,OAAO,CAACqC,GAAG,CAACwB,MAAM,CAACrC,CAAC,GAAG4C,SAAS;IACvC1G,YAAY,CAACsC,OAAO,IAAI,CAAC;EAC3B,CAAC;;EAED;EACApF,QAAQ,CAAC,UAAC4B,KAAK,EAAEyI,KAAK,EAAK;IACzB,IAAIC,mBAAmB,EAAEC,eAAe;IACxC,IAAI,EAAE,CAACD,mBAAmB,GAAGxI,UAAU,CAACsD,OAAO,KAAK,IAAI,IAAIkF,mBAAmB,CAACtE,MAAM,CAAC,IAAI,EAAE,CAACuE,eAAe,GAAGhI,MAAM,CAAC6C,OAAO,KAAK,IAAI,IAAImF,eAAe,CAAC9C,GAAG,CAAC,EAAE;MAC/J;IACF;IACA,IAAIrG,KAAK,EAAE;MACT;IACF;IACA,IAAI,CAACkB,QAAQ,CAAC8C,OAAO,KAAKvE,QAAQ,IAAIM,IAAI,CAAC,EAAE;MAC3C+H,YAAY,CAAC,CAAC;MACdhI,OAAO,IAAIA,OAAO,CAAC;QACjB6B,gBAAgB,EAAEA,gBAAgB,CAACqC,OAAO;QAC1CtC,YAAY,EAAEA,YAAY,CAACsC;MAC7B,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;;EAEF;EACA,IAAMoC,YAAY,GAAG,SAAfA,YAAYA,CAAGgD,KAAK,EAAI;IAC5B,IAAIvD,KAAK,CAACC,OAAO,CAACsD,KAAK,CAAC,EAAE;MACxB,OAAOA,KAAK,CAAC,CAAC,CAAC;IACjB,CAAC,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE;MACtD,IAAMlD,IAAI,GAAGD,MAAM,CAACC,IAAI,CAACkD,KAAK,CAAC;MAC/B,OAAOA,KAAK,CAAClD,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1B,CAAC,MAAM;MACL,OAAO;QACLlB,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE;MACL,CAAC;IACH;EACF,CAAC;EACD,OAAO,aAAavG,KAAK,CAAC2K,aAAa,CAAC,OAAO,EAAEhJ,KAAK,EAAE,aAAa3B,KAAK,CAAC2K,aAAa,CAAC3K,KAAK,CAAC4K,QAAQ,EAAE;IACvGC,QAAQ,EAAE;EACZ,CAAC,EAAE7G,eAAe,IAAI,aAAahE,KAAK,CAAC2K,aAAa,CAAC,QAAQ,EAAE;IAC/DG,GAAG,EAAEpI,SAAS;IACd6C,KAAK,EAAE5B;EACT,CAAC,EAAE,aAAa3D,KAAK,CAAC2K,aAAa,CAAC,gBAAgB,EAAE;IACpDI,UAAU,EAAE,KAAK;IACjBD,GAAG,EAAErI,MAAM;IACXkF,GAAG,EAAErE,aAAa;IAClB0H,WAAW,EAAE,IAAI;IACjBxJ,SAAS,EAAEA,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG;EACtE,CAAC,CAAC,CAAC,EAAE,CAACwC,eAAe,IAAI,aAAahE,KAAK,CAAC2K,aAAa,CAAC,MAAM,EAAE;IAChEG,GAAG,EAAEpI,SAAS;IACd6C,KAAK,EAAE5B;EACT,CAAC,EAAE,aAAa3D,KAAK,CAAC2K,aAAa,CAAC,eAAe,EAAE;IACnDM,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC;EACb,CAAC,CAAC,EAAE,aAAajL,KAAK,CAAC2K,aAAa,CAAC,mBAAmB,EAAE;IACxDI,UAAU,EAAE,KAAK;IACjBG,IAAI,EAAE/K,KAAK,CAACgL,UAAU;IACtBL,GAAG,EAAErI,MAAM;IACXkF,GAAG,EAAErE,aAAa;IAClB0H,WAAW,EAAE,IAAI;IACjBxJ,SAAS,EAAEA,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG;EACtE,CAAC,CAAC,CAAC,CAAC,EAAEC,QAAQ,CAAC;AACjB,CAAC;AAED,SAASrB,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}