{"ast":null,"code":"import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nvar _box1, _box2;\nvar boxStack = [];\nvar boxPool = /* @__PURE__ */new PrimitivePool(function () {\n  return new Box3();\n});\nexport function shapecast(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {\n  // setup\n  _box1 = boxPool.getPrimitive();\n  _box2 = boxPool.getPrimitive();\n  boxStack.push(_box1, _box2);\n  BufferStack.setBuffer(bvh._roots[root]);\n  var result = shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n\n  // cleanup\n  BufferStack.clearBuffer();\n  boxPool.releasePrimitive(_box1);\n  boxPool.releasePrimitive(_box2);\n  boxStack.pop();\n  boxStack.pop();\n  var length = boxStack.length;\n  if (length > 0) {\n    _box2 = boxStack[length - 1];\n    _box1 = boxStack[length - 2];\n  }\n  return result;\n}\nfunction shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc) {\n  var nodeScoreFunc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var nodeIndexByteOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var depth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var float32Array = BufferStack.float32Array,\n    uint16Array = BufferStack.uint16Array,\n    uint32Array = BufferStack.uint32Array;\n  var nodeIndex16 = nodeIndex32 * 2;\n  var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n  if (isLeaf) {\n    var offset = OFFSET(nodeIndex32, uint32Array);\n    var count = COUNT(nodeIndex16, uint16Array);\n    arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box1);\n    return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);\n  } else {\n    // Define these inside the function so it has access to the local variables needed\n    // when converting to the buffer equivalents\n    var getLeftOffset = function getLeftOffset(nodeIndex32) {\n      var uint16Array = BufferStack.uint16Array,\n        uint32Array = BufferStack.uint32Array;\n      var nodeIndex16 = nodeIndex32 * 2;\n\n      // traverse until we find a leaf\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        nodeIndex32 = LEFT_NODE(nodeIndex32);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n      return OFFSET(nodeIndex32, uint32Array);\n    };\n    var getRightEndOffset = function getRightEndOffset(nodeIndex32) {\n      var uint16Array = BufferStack.uint16Array,\n        uint32Array = BufferStack.uint32Array;\n      var nodeIndex16 = nodeIndex32 * 2;\n\n      // traverse until we find a leaf\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        // adjust offset to point to the right node\n        nodeIndex32 = RIGHT_NODE(nodeIndex32, uint32Array);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n\n      // return the end offset of the triangle range\n      return OFFSET(nodeIndex32, uint32Array) + COUNT(nodeIndex16, uint16Array);\n    };\n    var left = LEFT_NODE(nodeIndex32);\n    var right = RIGHT_NODE(nodeIndex32, uint32Array);\n    var c1 = left;\n    var c2 = right;\n    var score1, score2;\n    var box1, box2;\n    if (nodeScoreFunc) {\n      box1 = _box1;\n      box2 = _box2;\n\n      // bounding data is not offset\n      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n      score1 = nodeScoreFunc(box1);\n      score2 = nodeScoreFunc(box2);\n      if (score2 < score1) {\n        c1 = right;\n        c2 = left;\n        var temp = score1;\n        score1 = score2;\n        score2 = temp;\n        box1 = box2;\n        // box2 is always set before use below\n      }\n    }\n\n    // Check box 1 intersection\n    if (!box1) {\n      box1 = _box1;\n      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n    }\n    var isC1Leaf = IS_LEAF(c1 * 2, uint16Array);\n    var c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n    var c1StopTraversal;\n    if (c1Intersection === CONTAINED) {\n      var _offset = getLeftOffset(c1);\n      var end = getRightEndOffset(c1);\n      var _count = end - _offset;\n      c1StopTraversal = intersectsRangeFunc(_offset, _count, true, depth + 1, nodeIndexByteOffset + c1, box1);\n    } else {\n      c1StopTraversal = c1Intersection && shapecastTraverse(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n    }\n    if (c1StopTraversal) return true;\n\n    // Check box 2 intersection\n    // cached box2 will have been overwritten by previous traversal\n    box2 = _box2;\n    arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n    var isC2Leaf = IS_LEAF(c2 * 2, uint16Array);\n    var c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n    var c2StopTraversal;\n    if (c2Intersection === CONTAINED) {\n      var _offset2 = getLeftOffset(c2);\n      var _end = getRightEndOffset(c2);\n      var _count2 = _end - _offset2;\n      c2StopTraversal = intersectsRangeFunc(_offset2, _count2, true, depth + 1, nodeIndexByteOffset + c2, box2);\n    } else {\n      c2StopTraversal = c2Intersection && shapecastTraverse(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n    }\n    if (c2StopTraversal) return true;\n    return false;\n  }\n}","map":{"version":3,"names":["Box3","CONTAINED","arrayToBox","PrimitivePool","COUNT","OFFSET","LEFT_NODE","RIGHT_NODE","IS_LEAF","BOUNDING_DATA_INDEX","BufferStack","_box1","_box2","boxStack","boxPool","shapecast","bvh","root","intersectsBounds","intersectsRange","boundsTraverseOrder","byteOffset","getPrimitive","push","setBuffer","_roots","result","shapecastTraverse","geometry","clearBuffer","releasePrimitive","pop","length","nodeIndex32","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","arguments","undefined","nodeIndexByteOffset","depth","float32Array","uint16Array","uint32Array","nodeIndex16","isLeaf","offset","count","getLeftOffset","getRightEndOffset","left","right","c1","c2","score1","score2","box1","box2","temp","isC1Leaf","c1Intersection","c1StopTraversal","end","isC2Leaf","c2Intersection","c2StopTraversal"],"sources":["C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/three-mesh-bvh/src/core/cast/shapecast.js"],"sourcesContent":["import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}