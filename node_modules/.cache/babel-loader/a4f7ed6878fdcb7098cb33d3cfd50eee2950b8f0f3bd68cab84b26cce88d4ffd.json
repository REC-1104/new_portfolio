{"ast":null,"code":"import _classCallCheck from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _construct from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _toConsumableArray from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"children\", \"temporal\", \"frames\", \"limit\", \"blend\", \"scale\", \"opacity\", \"alphaTest\", \"color\", \"colorBlend\", \"resolution\", \"toneMapped\"],\n  _excluded2 = [\"castShadow\", \"bias\", \"mapSize\", \"size\", \"near\", \"far\", \"frames\", \"position\", \"radius\", \"amount\", \"intensity\", \"ambient\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { DiscardMaterial } from '../materials/DiscardMaterial.js';\nimport { version } from '../helpers/constants.js';\nfunction isLight(object) {\n  return object.isLight;\n}\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\nvar accumulativeContext = /*@__PURE__*/React.createContext(null);\nvar SoftShadowMaterial = /*@__PURE__*/shaderMaterial({\n  color: /*@__PURE__*/new THREE.Color(),\n  blend: 2.0,\n  alphaTest: 0.75,\n  opacity: 0,\n  map: null\n}, \"varying vec2 vUv;\\n   void main() {\\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n     vUv = uv;\\n   }\", \"varying vec2 vUv;\\n   uniform sampler2D map;\\n   uniform vec3 color;\\n   uniform float opacity;\\n   uniform float alphaTest;\\n   uniform float blend;\\n   void main() {\\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\\n     #include <tonemapping_fragment>\\n     #include <\".concat(version >= 154 ? 'colorspace_fragment' : 'encodings_fragment', \">\\n   }\"));\nvar AccumulativeShadows = /*@__PURE__*/React.forwardRef(function (_ref, forwardRef) {\n  var children = _ref.children,\n    temporal = _ref.temporal,\n    _ref$frames = _ref.frames,\n    frames = _ref$frames === void 0 ? 40 : _ref$frames,\n    _ref$limit = _ref.limit,\n    limit = _ref$limit === void 0 ? Infinity : _ref$limit,\n    _ref$blend = _ref.blend,\n    blend = _ref$blend === void 0 ? 20 : _ref$blend,\n    _ref$scale = _ref.scale,\n    scale = _ref$scale === void 0 ? 10 : _ref$scale,\n    _ref$opacity = _ref.opacity,\n    opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,\n    _ref$alphaTest = _ref.alphaTest,\n    alphaTest = _ref$alphaTest === void 0 ? 0.75 : _ref$alphaTest,\n    _ref$color = _ref.color,\n    color = _ref$color === void 0 ? 'black' : _ref$color,\n    _ref$colorBlend = _ref.colorBlend,\n    colorBlend = _ref$colorBlend === void 0 ? 2 : _ref$colorBlend,\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === void 0 ? 1024 : _ref$resolution,\n    _ref$toneMapped = _ref.toneMapped,\n    toneMapped = _ref$toneMapped === void 0 ? true : _ref$toneMapped,\n    props = _objectWithoutProperties(_ref, _excluded);\n  extend({\n    SoftShadowMaterial: SoftShadowMaterial\n  });\n  var gl = useThree(function (state) {\n    return state.gl;\n  });\n  var scene = useThree(function (state) {\n    return state.scene;\n  });\n  var camera = useThree(function (state) {\n    return state.camera;\n  });\n  var invalidate = useThree(function (state) {\n    return state.invalidate;\n  });\n  var gPlane = React.useRef(null);\n  var gLights = React.useRef(null);\n  var _React$useState = React.useState(function () {\n      return new ProgressiveLightMap(gl, scene, resolution);\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    plm = _React$useState2[0];\n  React.useLayoutEffect(function () {\n    plm.configure(gPlane.current);\n  }, []);\n  var api = React.useMemo(function () {\n    return {\n      lights: new Map(),\n      temporal: !!temporal,\n      frames: Math.max(2, frames),\n      blend: Math.max(2, frames === Infinity ? blend : frames),\n      count: 0,\n      getMesh: function getMesh() {\n        return gPlane.current;\n      },\n      reset: function reset() {\n        // Clear buffers, reset opacities, set frame count to 0\n        plm.clear();\n        var material = gPlane.current.material;\n        material.opacity = 0;\n        material.alphaTest = 0;\n        api.count = 0;\n      },\n      update: function update() {\n        var frames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        // Adapt the opacity-blend ratio to the number of frames\n        var material = gPlane.current.material;\n        if (!api.temporal) {\n          material.opacity = opacity;\n          material.alphaTest = alphaTest;\n        } else {\n          material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n          material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n        }\n\n        // Switch accumulative lights on\n        gLights.current.visible = true;\n        // Collect scene lights and meshes\n        plm.prepare();\n\n        // Update the lightmap and the accumulative lights\n        for (var i = 0; i < frames; i++) {\n          api.lights.forEach(function (light) {\n            return light.update();\n          });\n          plm.update(camera, api.blend);\n        }\n        // Switch lights off\n        gLights.current.visible = false;\n        // Restore lights and meshes\n        plm.finish();\n      }\n    };\n  }, [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(function () {\n    // Reset internals, buffers, ...\n    api.reset();\n    // Update lightmap\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  });\n\n  // Expose api, allow children to set itself as the main light source\n  React.useImperativeHandle(forwardRef, function () {\n    return api;\n  }, [api]);\n  useFrame(function () {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      invalidate();\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: function traverse() {\n      return null;\n    },\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"softShadowMaterial\", {\n    transparent: true,\n    depthWrite: false,\n    toneMapped: toneMapped,\n    color: color,\n    blend: colorBlend,\n    map: plm.progressiveLightMap2.texture\n  })));\n});\nvar RandomizedLight = /*@__PURE__*/React.forwardRef(function (_ref2, forwardRef) {\n  var _ref2$castShadow = _ref2.castShadow,\n    castShadow = _ref2$castShadow === void 0 ? true : _ref2$castShadow,\n    _ref2$bias = _ref2.bias,\n    bias = _ref2$bias === void 0 ? 0.001 : _ref2$bias,\n    _ref2$mapSize = _ref2.mapSize,\n    mapSize = _ref2$mapSize === void 0 ? 512 : _ref2$mapSize,\n    _ref2$size = _ref2.size,\n    size = _ref2$size === void 0 ? 5 : _ref2$size,\n    _ref2$near = _ref2.near,\n    near = _ref2$near === void 0 ? 0.5 : _ref2$near,\n    _ref2$far = _ref2.far,\n    far = _ref2$far === void 0 ? 500 : _ref2$far,\n    _ref2$frames = _ref2.frames,\n    frames = _ref2$frames === void 0 ? 1 : _ref2$frames,\n    _ref2$position = _ref2.position,\n    position = _ref2$position === void 0 ? [0, 0, 0] : _ref2$position,\n    _ref2$radius = _ref2.radius,\n    radius = _ref2$radius === void 0 ? 1 : _ref2$radius,\n    _ref2$amount = _ref2.amount,\n    amount = _ref2$amount === void 0 ? 8 : _ref2$amount,\n    _ref2$intensity = _ref2.intensity,\n    intensity = _ref2$intensity === void 0 ? version >= 155 ? Math.PI : 1 : _ref2$intensity,\n    _ref2$ambient = _ref2.ambient,\n    ambient = _ref2$ambient === void 0 ? 0.5 : _ref2$ambient,\n    props = _objectWithoutProperties(_ref2, _excluded2);\n  var gLights = React.useRef(null);\n  var length = _construct(THREE.Vector3, _toConsumableArray(position)).length();\n  var parent = React.useContext(accumulativeContext);\n  var update = React.useCallback(function () {\n    var light;\n    if (gLights.current) {\n      for (var l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          var lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          var phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length].concat(_toConsumableArray(position)));\n  var api = React.useMemo(function () {\n    return {\n      update: update\n    };\n  }, [update]);\n  React.useImperativeHandle(forwardRef, function () {\n    return api;\n  }, [api]);\n  React.useLayoutEffect(function () {\n    var group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return function () {\n      return void parent.lights.delete(group.uuid);\n    };\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, function (_, index) {\n    return /*#__PURE__*/React.createElement(\"directionalLight\", {\n      key: index,\n      castShadow: castShadow,\n      \"shadow-bias\": bias,\n      \"shadow-mapSize\": [mapSize, mapSize],\n      intensity: intensity / amount\n    }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n      attach: \"shadow-camera\",\n      args: [-size, size, size, -size, near, far]\n    }));\n  }));\n});\n\n// Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\nvar ProgressiveLightMap = /*#__PURE__*/function () {\n  function ProgressiveLightMap(renderer, scene) {\n    var _this = this;\n    var res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1024;\n    _classCallCheck(this, ProgressiveLightMap);\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null;\n    this.clearColor = new THREE.Color();\n    this.clearAlpha = 0;\n\n    // Create the Progressive LightMap Texture\n    var textureParams = {\n      type: THREE.HalfFloatType,\n      magFilter: THREE.NearestFilter,\n      minFilter: THREE.NearestFilter\n    };\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, textureParams);\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, textureParams);\n\n    // Inject some spicy new logic into a standard phong material\n    this.discardMat = new DiscardMaterial();\n    this.targetMat = new THREE.MeshLambertMaterial({\n      fog: false\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n    this.targetMat.onBeforeCompile = function (shader) {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }';\n\n      // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n      var bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + 'uniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\\n      }\";\n\n      // Set the Previous Frame's Texture Buffer and Averaging Window\n      shader.uniforms.previousShadowMap = _this.previousShadowMap;\n      shader.uniforms.averagingWindow = _this.averagingWindow;\n    };\n  }\n  _createClass(ProgressiveLightMap, [{\n    key: \"clear\",\n    value: function clear() {\n      var _this2 = this;\n      this.renderer.getClearColor(this.clearColor);\n      this.clearAlpha = this.renderer.getClearAlpha();\n      this.renderer.setClearColor('black', 1);\n      this.renderer.setRenderTarget(this.progressiveLightMap1);\n      this.renderer.clear();\n      this.renderer.setRenderTarget(this.progressiveLightMap2);\n      this.renderer.clear();\n      this.renderer.setRenderTarget(null);\n      this.renderer.setClearColor(this.clearColor, this.clearAlpha);\n      this.lights = [];\n      this.meshes = [];\n      this.scene.traverse(function (object) {\n        if (isGeometry(object)) {\n          _this2.meshes.push({\n            object: object,\n            material: object.material\n          });\n        } else if (isLight(object)) {\n          _this2.lights.push({\n            object: object,\n            intensity: object.intensity\n          });\n        }\n      });\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare() {\n      var _this3 = this;\n      this.lights.forEach(function (light) {\n        return light.object.intensity = 0;\n      });\n      this.meshes.forEach(function (mesh) {\n        return mesh.object.material = _this3.discardMat;\n      });\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.lights.forEach(function (light) {\n        return light.object.intensity = light.intensity;\n      });\n      this.meshes.forEach(function (mesh) {\n        return mesh.object.material = mesh.material;\n      });\n    }\n  }, {\n    key: \"configure\",\n    value: function configure(object) {\n      this.object = object;\n    }\n  }, {\n    key: \"update\",\n    value: function update(camera) {\n      var blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      if (!this.object) return;\n      // Set each object's material to the UV Unwrapped Surface Mapping Version\n      this.averagingWindow.value = blendWindow;\n      this.object.material = this.targetMat;\n      // Ping-pong two surface buffers for reading/writing\n      var activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n      var inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n      // Render the object's surface maps\n      var oldBg = this.scene.background;\n      this.scene.background = null;\n      this.renderer.setRenderTarget(activeMap);\n      this.previousShadowMap.value = inactiveMap.texture;\n      this.buffer1Active = !this.buffer1Active;\n      this.renderer.render(this.scene, camera);\n      this.renderer.setRenderTarget(null);\n      this.scene.background = oldBg;\n    }\n  }]);\n  return ProgressiveLightMap;\n}();\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };","map":{"version":3,"names":["_extends","THREE","React","extend","useThree","useFrame","shaderMaterial","DiscardMaterial","version","isLight","object","isGeometry","geometry","accumulativeContext","createContext","SoftShadowMaterial","color","Color","blend","alphaTest","opacity","map","concat","AccumulativeShadows","forwardRef","_ref","children","temporal","_ref$frames","frames","_ref$limit","limit","Infinity","_ref$blend","_ref$scale","scale","_ref$opacity","_ref$alphaTest","_ref$color","_ref$colorBlend","colorBlend","_ref$resolution","resolution","_ref$toneMapped","toneMapped","props","_objectWithoutProperties","_excluded","gl","state","scene","camera","invalidate","gPlane","useRef","gLights","_React$useState","useState","ProgressiveLightMap","_React$useState2","_slicedToArray","plm","useLayoutEffect","configure","current","api","useMemo","lights","Map","Math","max","count","getMesh","reset","clear","material","update","arguments","length","undefined","min","visible","prepare","i","forEach","light","finish","useImperativeHandle","createElement","traverse","ref","Provider","value","receiveShadow","rotation","PI","transparent","depthWrite","progressiveLightMap2","texture","RandomizedLight","_ref2","_ref2$castShadow","castShadow","_ref2$bias","bias","_ref2$mapSize","mapSize","_ref2$size","size","_ref2$near","near","_ref2$far","far","_ref2$frames","_ref2$position","position","_ref2$radius","radius","_ref2$amount","amount","_ref2$intensity","intensity","_ref2$ambient","ambient","_excluded2","_construct","Vector3","_toConsumableArray","parent","useContext","useCallback","l","random","set","MathUtils","randFloatSpread","lambda","acos","phi","cos","abs","sin","group","uuid","delete","Array","from","_","index","key","attach","args","renderer","_this","res","_classCallCheck","buffer1Active","meshes","clearColor","clearAlpha","textureParams","type","HalfFloatType","magFilter","NearestFilter","minFilter","progressiveLightMap1","WebGLRenderTarget","discardMat","targetMat","MeshLambertMaterial","fog","previousShadowMap","averagingWindow","onBeforeCompile","shader","vertexShader","slice","bodyStart","fragmentShader","indexOf","uniforms","_createClass","_this2","getClearColor","getClearAlpha","setClearColor","setRenderTarget","push","_this3","mesh","blendWindow","activeMap","inactiveMap","oldBg","background","render"],"sources":["C:/Users/Dhruv/OneDrive/Documents/GitHub/new_portfolio/node_modules/@react-three/drei/core/AccumulativeShadows.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { DiscardMaterial } from '../materials/DiscardMaterial.js';\nimport { version } from '../helpers/constants.js';\n\nfunction isLight(object) {\n  return object.isLight;\n}\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\nconst accumulativeContext = /*@__PURE__*/React.createContext(null);\nconst SoftShadowMaterial = /*@__PURE__*/shaderMaterial({\n  color: /*@__PURE__*/new THREE.Color(),\n  blend: 2.0,\n  alphaTest: 0.75,\n  opacity: 0,\n  map: null\n}, `varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }`, `varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n   }`);\nconst AccumulativeShadows = /*@__PURE__*/React.forwardRef(({\n  children,\n  temporal,\n  frames = 40,\n  limit = Infinity,\n  blend = 20,\n  scale = 10,\n  opacity = 1,\n  alphaTest = 0.75,\n  color = 'black',\n  colorBlend = 2,\n  resolution = 1024,\n  toneMapped = true,\n  ...props\n}, forwardRef) => {\n  extend({\n    SoftShadowMaterial\n  });\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const invalidate = useThree(state => state.invalidate);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    getMesh: () => gPlane.current,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      const material = gPlane.current.material;\n      material.opacity = 0;\n      material.alphaTest = 0;\n      api.count = 0;\n    },\n    update: (frames = 1) => {\n      // Adapt the opacity-blend ratio to the number of frames\n      const material = gPlane.current.material;\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.alphaTest = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n      }\n\n      // Switch accumulative lights on\n      gLights.current.visible = true;\n      // Collect scene lights and meshes\n      plm.prepare();\n\n      // Update the lightmap and the accumulative lights\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      }\n      // Switch lights off\n      gLights.current.visible = false;\n      // Restore lights and meshes\n      plm.finish();\n    }\n  }), [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset();\n    // Update lightmap\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  });\n\n  // Expose api, allow children to set itself as the main light source\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      invalidate();\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"softShadowMaterial\", {\n    transparent: true,\n    depthWrite: false,\n    toneMapped: toneMapped,\n    color: color,\n    blend: colorBlend,\n    map: plm.progressiveLightMap2.texture\n  })));\n});\nconst RandomizedLight = /*@__PURE__*/React.forwardRef(({\n  castShadow = true,\n  bias = 0.001,\n  mapSize = 512,\n  size = 5,\n  near = 0.5,\n  far = 500,\n  frames = 1,\n  position = [0, 0, 0],\n  radius = 1,\n  amount = 8,\n  intensity = version >= 155 ? Math.PI : 1,\n  ambient = 0.5,\n  ...props\n}, forwardRef) => {\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    const group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return () => void parent.lights.delete(group.uuid);\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n});\n\n// Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\nclass ProgressiveLightMap {\n  constructor(renderer, scene, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null;\n    this.clearColor = new THREE.Color();\n    this.clearAlpha = 0;\n\n    // Create the Progressive LightMap Texture\n    const textureParams = {\n      type: THREE.HalfFloatType,\n      magFilter: THREE.NearestFilter,\n      minFilter: THREE.NearestFilter\n    };\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, textureParams);\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, textureParams);\n\n    // Inject some spicy new logic into a standard phong material\n    this.discardMat = new DiscardMaterial();\n    this.targetMat = new THREE.MeshLambertMaterial({\n      fog: false\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }';\n\n      // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + 'uniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\n      }`;\n\n      // Set the Previous Frame's Texture Buffer and Averaging Window\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n  clear() {\n    this.renderer.getClearColor(this.clearColor);\n    this.clearAlpha = this.renderer.getClearAlpha();\n    this.renderer.setClearColor('black', 1);\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(null);\n    this.renderer.setClearColor(this.clearColor, this.clearAlpha);\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isGeometry(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.discardMat);\n  }\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n  configure(object) {\n    this.object = object;\n  }\n  update(camera, blendWindow = 100) {\n    if (!this.object) return;\n    // Set each object's material to the UV Unwrapped Surface Mapping Version\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat;\n    // Ping-pong two surface buffers for reading/writing\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n    // Render the object's surface maps\n    const oldBg = this.scene.background;\n    this.scene.background = null;\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n    this.scene.background = oldBg;\n  }\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}